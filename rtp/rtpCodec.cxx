
/* ====================================================================
 * The Vovida Software License, Version 1.0 
 * 
 * Copyright (c) 2000 Vovida Networks, Inc.  All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 
 * 3. The names "VOCAL", "Vovida Open Communication Application Library",
 *    and "Vovida Open Communication Application Library (VOCAL)" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact vocal@vovida.org.
 *
 * 4. Products derived from this software may not be called "VOCAL", nor
 *    may "VOCAL" appear in their name, without prior written
 *    permission of Vovida Networks, Inc.
 * 
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
 * NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL VOVIDA
 * NETWORKS, INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT DAMAGES
 * IN EXCESS OF $1,000, NOR FOR ANY INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 * 
 * ====================================================================
 * 
 * This software consists of voluntary contributions made by Vovida
 * Networks, Inc. and many individuals on behalf of Vovida Networks,
 * Inc.  For more information on Vovida Networks, Inc., please see
 * <http://www.vovida.org/>.
 *
 */

static const char* const rtpCodec_cxx_Version =
    "$Id: rtpCodec.cxx,v 1.2 2004/11/19 01:54:38 greear Exp $";

#include <errno.h>

#include "global.h"
#include "rtpCodec.h"

#include "cpLog.h"
#include "g711.h"

#include "rtpTypes.h"
#include "RtpPacket.hxx"

const int numRtpCodecInfo = 17;

RtpCodecInfo rtpCodecInfo[numRtpCodecInfo] = 
{
    // g711ulaw 
    // 40 words, 80 bytes silence payload for 10ms packetization - 
    { rtpPayloadPCMU, "PCMU", 80, 
    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF }
    },

    // g711ulaw 
    // 80 words, 160 bytes silence payload for 20ms packetization - 
    { rtpPayloadPCMU, "PCMU", 160, 
    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF }
    },

    // g711ulaw 
    // 120 words, 240 bytes silence payload for 30ms packetization - 
    { rtpPayloadPCMU, "PCMU", 240, 
    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF }
    },

    // g711alaw 
    // 40 words, 80 bytes silence payload for 10ms packetization - 
    { rtpPayloadPCMA, "PCMA", 80,
    { 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
      0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
      0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
      0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55 } 
    },

    // g711alaw 
    // 80 words, 160 bytes silence payload for 20ms packetization - 
    { rtpPayloadPCMA, "PCMA", 160,
    { 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
      0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
      0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
      0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
      0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
      0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
      0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
      0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55 } 
    },

    // g711alaw 
    // 120 words, 240 bytes silence payload for 30ms packetization - 
    { rtpPayloadPCMA, "PCMA", 240,
    { 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
      0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
      0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
      0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
      0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
      0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
      0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
      0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
      0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
      0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
      0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
      0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55 } 
    },

    // gsmfr 
    // 17 words, 34 bytes silence payload for 20ms packetization - 
    { rtpPayloadGSM, "GSMFR", 34,
/*
    { 0xD9, 0xEA, 0xC4, 0x6C, 0xE1, 0x84, 0x00, 0x39, 0x5C, 0x91, 0xC9, 0x2B, 0xA6, 0xA0, 0x49, 0x24, 0x95, 0x37, 0x24, 0x76, 
      0xE0, 0x4B, 0x23, 0x8E, 0x56, 0xDB, 0x56, 0xA0, 0x48, 0xE5, 0x8E, 0x4B, 0x2C, 0x52 } 
*/
    { 0xD8, 0x60, 0x8A, 0xD1, 0x29, 0x50, 0x0, 0x49, 0x24, 0x92, 0x49, 0x24, 0x55, 0x80, 0x2B, 0x1A, 0x6D, 0xB6, 0x9B, 0x92,
    0xC0, 0x26, 0xDB, 0x72, 0x47, 0x64, 0xD6, 0xC0, 0x3A, 0xDB, 0x76, 0x39, 0x1B, 0x0 }
    },

    // gsmfr 
    // 16 words, 32 bytes silence payload for 20ms packetization - 
    { rtpPayloadGSMEFR, "GSMEFR", 32,
/*
    { 0xC4, 0x8F, 0x43, 0xF9, 0x0A, 0xEA, 0xD6, 0x00, 0x00, 0x00, 0x00, 0x01, 0xB5, 0x80, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAC, 
      0x00, 0x00, 0x00, 0x00, 0x03, 0x6B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
 */
    { 0xCE, 0x7, 0x23, 0x9B, 0xBF, 0x8E, 0x56, 0x0, 0x0, 0x0, 0x0, 0x1, 0x5, 0x9C, 0x10, 0xD0, 0xB9, 0x3A, 0x58, 0xEB,
    0x5F, 0xA7, 0x66, 0xBA, 0x15, 0xF0, 0x34, 0x67, 0x5, 0x39, 0x25, 0x0 }
    },

    // g723r53 
    // 10 words, 20 bytes silence payload for 30 ms packetization - 
    { rtpPayloadG723, "G723R53", 20,
    { 0x95, 0x0A, 0xCE, 0xDA, 0x3F, 0x3E, 0x84, 0xC3, 0xB3, 0x4C, 0xEB, 0x62, 0xA6, 0x2A, 0x0F, 0x4C, 0x72, 0xCE, 0xA9, 0xA1 } 
    },

    // g723r63 
    // 12 words, 24 bytes silence payload for 30 ms packetization - 
    { rtpPayloadG723, "G723R63", 24,
    { 0xE8, 0x2E, 0xCE, 0xDE, 0xC8, 0xB8, 0x6A, 0x84, 0xB1, 0x61, 0xE2, 0x99, 0xBE, 0x0C, 0x69, 0x71, 0x0D, 0x99, 0x53, 0x72, 
      0xFF, 0xAD, 0xB6, 0xE8 } 
    },

    // g732ar63 TODO
    // find specs

    // g723ar53 TODO
    // find specs

    // g728 TODO
    // 20 words, 40 bytes silence payload for 20ms packetization -
    { rtpPayloadG728, "G728", 40,
    { 0x30, 0xC1, 0x13, 0x4C, 0xC1, 0x4, 0x4C, 0x30, 0x4, 0x13, 0xE1, 0x14, 0x22, 0x8A, 0xA3, 0x54, 0x1C, 0x65, 0x14, 0xD0,
    0x3B, 0x95, 0x53, 0x8C, 0x14, 0x9C, 0xD, 0x65, 0x1C, 0x12, 0x7B, 0xD6, 0x0, 0x8C, 0xC0, 0xD4, 0x81, 0x3A, 0x8C, 0x12 }
    },

    // g726r16 
    // 20 words, 40 bytes silence payload for 20ms packetization - 
    { rtpPayloadG726_16, "G726R16", 40,
    { 0x03, 0x33, 0xC3, 0x3C, 0x3C, 0xCF, 0x3C, 0x03, 0xCF, 0x00, 0xF0, 0xF3, 0x3F, 0xFF, 0xC0, 0xCF, 0xF0, 0xF3, 0x00, 0xFC, 
      0xFF, 0x0C, 0x3C, 0x00, 0x0C, 0xFF, 0xCC, 0x03, 0x0C, 0xC0, 0x0C, 0xF0, 0xC3, 0x30, 0x30, 0x00, 0xCC, 0xF0, 0xF3, 0x0C } 
    },

    // g726r16 
    // 100 words, 200 bytes silence payload for 100ms packetization - 
    // Any shorter payload will result in louder-hissing noise.
    // Any re-arrangement of the payload order will result in noise as well.
    { rtpPayloadG726_16, "G726R16", 200,
    { 0x3, 0xCF, 0xCF, 0xC0, 0x0, 0x0, 0xC, 0x0, 0xC, 0xCC, 0x30, 0xCC, 0xC3, 0xFC, 0x3C, 0x0, 0xCF, 0x0, 0xC, 0x3,
    0x3, 0x3, 0xFC, 0x3F, 0xFF, 0x33, 0xF3, 0x30, 0xFF, 0x30, 0xFF, 0xF3, 0xF3, 0xF3, 0xFC, 0xFC, 0xF0, 0xC0, 0xC3, 0x0,

    0x0, 0x0, 0xCC, 0xC, 0xC3, 0xF, 0xC, 0xF, 0x0, 0x30, 0xC0, 0xF0, 0x30, 0xCC, 0x30, 0xF0, 0xC, 0xFF, 0xC0, 0x3F,
    0xF3, 0xFC, 0x33, 0xFF, 0x3F, 0xCF, 0x3F, 0x3F, 0x33, 0x3C, 0xC0, 0xF3, 0x3, 0xFC, 0x0, 0xC0, 0xCC, 0xF3, 0xCC, 0xC0,

    0x0, 0x0, 0x3, 0x0, 0x3, 0xF, 0x0, 0x30, 0x30, 0xC3, 0xF3, 0xF3, 0xF, 0xF3, 0xCF, 0xCF, 0x3F, 0xFF, 0x3F, 0xFC,
    0xFC, 0xF3, 0xCF, 0xF3, 0x3, 0xCC, 0x0, 0x30, 0xC, 0xC, 0xF0, 0x0, 0xCC, 0xC3, 0x0, 0xCC, 0x0, 0x33, 0x0, 0x3C,

    0x30, 0x3F, 0xC0, 0xFF, 0xFC, 0xCF, 0x3C, 0xFF, 0x33, 0xF0, 0x3F, 0x3C, 0xFF, 0x3F, 0x3F, 0xCF, 0x3C, 0xFF, 0x30, 0x3C,
    0x0, 0xC, 0xC0, 0x0, 0xC3, 0x0, 0xCC, 0xC0, 0xC, 0xC, 0x30, 0x30, 0x30, 0xCF, 0xC3, 0x3C, 0xF0, 0xFF, 0xFF, 0x33,

    0x3F, 0x0, 0xF3, 0xF0, 0xFC, 0x3F, 0xC3, 0xF, 0xF3, 0x3F, 0x33, 0xF, 0xFC, 0x30, 0xC0, 0xFC, 0xC, 0xF3, 0x0, 0x33,
    0x0, 0x0, 0x0, 0xC3, 0x30, 0x3, 0xC3, 0xC, 0xCF, 0xC3, 0xF3, 0xF0, 0xCF, 0xC0, 0xC3, 0xC, 0xC0, 0xFF, 0xC0, 0x30 }
    },

    // g726r24 
    // 30 words, 60 bytes silence payload for 20ms packetization - 
    { rtpPayloadG726_24, "G726R24", 60,
    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF } 
    },

    // g726r32 
    // 40 words, 80 bytes silence payload for 20ms packetization - 
    { rtpPayloadG726_32, "G726R32", 80,
    { 0xFF, 0xF1, 0xEF, 0xEF, 0xFF, 0xF1, 0xEF, 0xEF, 0x1F, 0xFF, 0xFE, 0xEF, 0xFF, 0xFE, 0x1F, 0x1F, 0xFE, 0x11, 0xEF, 0x1E, 
      0x1E, 0xEF, 0xEF, 0xFF, 0xFE, 0xFE, 0xEE, 0xEF, 0xEE, 0x1F, 0xEF, 0xFE, 0xFE, 0xE1, 0xF1, 0xFE, 0xE1, 0xFF, 0xFF, 0xEF, 
      0xFE, 0xFF, 0xEF, 0xFE, 0xF1, 0xEF, 0xFE, 0xFF, 0xEF, 0xFE, 0xFF, 0x1E, 0xEF, 0xFF, 0x1F, 0xFC, 0xFF, 0xFF, 0x1F, 0xFF, 
      0xEF, 0xFF, 0xFF, 0x1F, 0xFF, 0x1E, 0x1E, 0xEE, 0xF1, 0x1F, 0xFF, 0xEE, 0x1F, 0xFE, 0xFE, 0xEE, 0x1F, 0xFF, 0xFE, 0xFF } 
    },

    // linear16mono TODO
    // find specs

    // g729 all versions TODO
    // 100 words, 200 bytes silence payload for 200 ms packetization.
    // Any shorter payload will result in helicopter-effect noise.
    // Any re-arrangement of the payload order will result in noise as well.
    { rtpPayloadG729, "G729", 200,
    { 0x95, 0x1A, 0xEF, 0x40, 0x0, 0xFA, 0xDB, 0x0, 0x7, 0xD6, 0xF9, 0xCE, 0x5C, 0x80, 0x20, 0x1D, 0x8C, 0x2, 0x6F, 0xD6,
    0xE0, 0x48, 0x6B, 0x77, 0xA2, 0xB, 0xDB, 0x76, 0xA7, 0xD0, 0x10, 0x8B, 0x7C, 0x3B, 0x19, 0x3B, 0x38, 0x6E, 0x81, 0x5A,
    0x91, 0x32, 0xBB, 0x6, 0xE0, 0xB2, 0xC0, 0xB5, 0xB8, 0x1E, 0x2E, 0x1E, 0x58, 0xE6, 0xC8, 0xFB, 0x1F, 0x36, 0xC, 0x10,
    0x20, 0x2A, 0x74, 0x97, 0x8C, 0xF2, 0x19, 0xC3, 0xAD, 0x50, 0x40, 0xA, 0xF2, 0x5A, 0xC8, 0xC2, 0x9B, 0x84, 0xD6, 0xDA,
    0x79, 0x45, 0xB8, 0x12, 0xC0, 0x7A, 0xE7, 0x19, 0x9D, 0x91, 0x60, 0x6B, 0xB2, 0x41, 0x93, 0x1A, 0x2C, 0xB6, 0x3E, 0x10,

    0x79, 0x99, 0x3A, 0x60, 0x38, 0x7A, 0x13, 0x9D, 0x95, 0x1A, 0x20, 0x3A, 0x7D, 0x50, 0xE, 0x3B, 0x75, 0x8D, 0xE6, 0x9E,
    0xE0, 0x48, 0x7E, 0xA, 0xFD, 0x32, 0x3, 0xFB, 0xEE, 0xD1, 0x28, 0xED, 0xF4, 0x5C, 0xEF, 0x3A, 0xE6, 0xE8, 0xB3, 0xD3,
    0xE0, 0x3C, 0x20, 0x4D, 0x2A, 0x2A, 0x5D, 0x19, 0x7F, 0xD6, 0x60, 0x93, 0x60, 0x4E, 0x96, 0xE2, 0x19, 0x3D, 0x60, 0x58,
    0x30, 0xEB, 0x58, 0x74, 0x5A, 0xF2, 0x9, 0x68, 0x8F, 0x96, 0x79, 0xE, 0xF5, 0xAB, 0x60, 0x3, 0xC0, 0xDA, 0xEB, 0x94,
    0x62, 0x2C, 0xED, 0xEC, 0x33, 0x42, 0xC9, 0xBF, 0x1B, 0x9E, 0xE0, 0x3B, 0x62, 0x7F, 0xBC, 0x6B, 0xD9, 0x31, 0x5A, 0x96 }
    },

    // unknown
    // 240 words, 480 bytes silence payload - 
    { rtpPayloadUndefined, "UNKNOWN", 480, 
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
    }
};
/*  extra unused silence packets from ducati vsp ENG-86534
    probably number under another alias

    // g728r16 
    // 20 words, 40 bytes silence payload for 20ms packetization - 
    { 0x58C0, 0x324C, 0xAD01, 0xD83F, 0xC415, 0x3DF6, 0xC1CF, 0xA0C5, 0x4229, 0x8442, 
    0x76D5, 0x62CD, 0xCD1C, 0xC92D, 0x2D02, 0x30D8, 0x624B, 0x568C, 0x0A3C, 0x3CC2 } 

    // g729r8 
    // 10 words, 20 bytes silence payload for 20ms packetization - 
    { 0x4057, 0x8C6E, 0x309A, 0x87E8, 0xCA05, 0xF8FE, 0xA91E, 0xCCE3, 0x56A1, 0xE590 } 
*/


// This now works in-line, and on the stack, instead of creating new packets.
void
convertRtpPacketCodec (RtpPayloadType toType, RtpPacket& packet)
{
   char buf[1012];
   //RtpPacket* p = new RtpPacket(packet, 1012);
   

   int result_size = convertCodec (packet.getPayloadType(), toType,
                                   packet.getPayloadLoc(), buf,
                                   packet.getPayloadUsage(), 1012);

   packet.setPayloadType(toType);
   packet.setPayloadUsage(result_size);
   memcpy(packet.getPayloadLoc(), buf, result_size);
   
}


// return value is size of converted data stored at out_data
int
convertCodec(RtpPayloadType fromType, RtpPayloadType toType,
             char* in_data, char* out_data, int in_len, int max_out_len)
{
    int result_len = -1;

    unsigned char* charBuff = (unsigned char*)out_data;
    short* shortBuff = (short*)out_data;
    unsigned char* charPayload = (unsigned char*)in_data;
    short* shortPayload = (short*)in_data;


    switch (fromType)
    {
        case rtpPayloadPCMU :
        {
            switch (toType)
            {
                case rtpPayloadL16_mono :
                case rtpPayloadL16_8k_mono :
		{
                   for (int i = 0; i < in_len; i++) {
                      if (i * 2 > max_out_len) {
                         // About to buffer overflow!!!
                         assert(0);
                         return -EINVAL;
                      }
                      shortBuff[i] = ulaw2linear (charPayload[i]);
                   }
                   result_len = in_len * 2;
                   break;
		}
                default :
                cpLog(LOG_DEBUG, "Unsupported converstion %d -> %d",
                      fromType, toType);
                break;
            }
        }
        break;
        case rtpPayloadL16_mono :
        case rtpPayloadL16_8k_mono :
        {
            switch (toType)
            {
                case rtpPayloadPCMU :
		{
                   for (int i = 0; i < in_len / 2; i++) {
                      if (i * 2 > max_out_len) {
                         // About to buffer overflow!!!
                         assert(0);
                         return -EINVAL;
                      }

                      charBuff[i] = linear2ulaw (shortPayload[i]);
                   }
                   result_len = in_len / 2;
                   break;
		}
                default :
                cpLog(LOG_DEBUG, "Unsupported conversion %d -> %d",
                      fromType, toType);
                break;
            }
        }
        break;
        default :
        {
            cpLog(LOG_DEBUG, "Unsupported conversion %d -> %d",
                  fromType, toType);
            break;
        }
    }

    return result_len;
}


void rtp_htonl (RtpPacket* p)
{
#if __BYTE_ORDER == __LITTLE_ENDIAN
    unsigned char tdata;
    if (p->getPayloadType() == rtpPayloadL16_mono)
    {
        unsigned char* data = (unsigned char*) p->getPayloadLoc();
        for (int i = 0; i < p->getPayloadUsage(); i = i + 2)
        {
            tdata = data[i];
            data[i] = data[i + 1];
            data[i + 1] = tdata;
        }
    }
#endif
    p->setConvertedToNBO(true);
}


void rtp_ntohl (RtpPacket* p)
{
#if __BYTE_ORDER == __LITTLE_ENDIAN
    unsigned char tdata;
    if (p->getPayloadType() == rtpPayloadL16_mono)
    {
        unsigned char* data = (unsigned char*) p->getPayloadLoc();
        for (int i = 0; i < p->getPayloadUsage(); i = i + 2)
        {
            tdata = data[i];
            data[i] = data[i + 1];
            data[i + 1] = tdata;
        }
    }
#endif
    p->setConvertedToHBO(true);
}


char* findSilenceCodec( RtpPayloadType type, int len )
{
    for( int i = 0; i < numRtpCodecInfo; i++ )
    {
        if( rtpCodecInfo[i].payloadType == type  && rtpCodecInfo[i].length == len )
        {
            cpLog( LOG_DEBUG_STACK, "Silence packet template found at index %d",
                   i );
            return (char*)&rtpCodecInfo[i].silence;
        }
    }

    cpLog( LOG_DEBUG_STACK, "Silence unknown for type:%d, len%d", type, len );
    return 0;
}

char* findSilenceCodecString( char* codecStringInput, int len )
{
    for( int i = 0; i < numRtpCodecInfo; i++ )
    {
        if( (strcmp(rtpCodecInfo[i].codecString, codecStringInput) == 0) && rtpCodecInfo[i].length == len )
        {
            cpLog( LOG_DEBUG_STACK, "Silence packet template found at index %d",
                   i );
            return (char*)&rtpCodecInfo[i].silence;
        }
    }

    cpLog( LOG_DEBUG_STACK, "Silence unknown for type:%s, len%d", codecStringInput, len );
    return 0;
}


void createSilenceCodec (char* buffer, RtpPayloadType type, int len)
{
    switch (type)
    {
        case rtpPayloadPCMU:
        memset (buffer, 0xFF, len);
        break;
        case rtpPayloadL16_mono:   // debug
        case rtpPayloadG729:   // debug
        default:
        cpLog (LOG_ERR, "Can't make exact silence for type: &d", (int)type);
        memset (buffer, 0, len);
        break;
    }
}


// sets the exact networkFormat information, esp network_perSampleSize
void setNetworkFormatCodec()
{
    return ;
}
